@GenModel(featureDelegation="Dynamic",
	rootExtendsClass="org.eclipse.emf.internal.cdo.CDOObjectImpl",
	rootExtendsInterface="org.eclipse.emf.cdo.CDOObject",
	modelPluginVariables="org.eclipse.xtext.xbase.lib org.eclipse.emf.ecore.xcore.lib org.eclipse.emf.cdo",
	childCreationExtenders="true",
	editDirectory="/ch.flatland.cdo.model.base.edit/src",
	modelDirectory="/ch.flatland.cdo.model.base/src",
	creationIcons="false")
package ch.flatland.cdo.model.base
//featureDelegation="Dynamic",
/*
 * Base elements all Concepts should at least inherit from.
 * Provides generic features.
 */
import org.eclipse.emf.common.util.BasicEList
import ch.flatland.cdo.model.base.BasePackage.Literals

abstract class FLElement {
	String[1] name
	/* 
	 * Markdown formatted description
	 * http://en.wikipedia.org/wiki/Markdown
	 */
	@GenModel(propertyMultiLine="true")
	String description
	contains FLTrace[] traces
	contains FLProperty[] properties
	refers FLElement[] traceToOwn get {
		return traces.toFilterByType(FLTraceType.OWN)
	}
	refers FLElement[] traceToUse get {
		return traces.toFilterByType(FLTraceType.USE)
	}
	refers FLElement[] traceToRealize get {
		return traces.toFilterByType(FLTraceType.REALIZE)
	}
	refers FLElement[] traceToSpecify get {
		return traces.toFilterByType(FLTraceType.SPECIFY)
	}
	refers FLElement[] traceToImplement get {
		return traces.toFilterByType(FLTraceType.IMPLEMENT)
	}
	refers FLElement[] traceToElaborate get {
		return traces.toFilterByType(FLTraceType.ELABORATE)
	}
	refers FLElement[] traceToDerive get {
		return traces.toFilterByType(FLTraceType.DERIVE)
	}
	refers FLElement[] traceToValidate get {
		return traces.toFilterByType(FLTraceType.VALIDATE)
	}
	refers FLElement[] traceToTest get {
		return traces.toFilterByType(FLTraceType.TEST)
	}
	refers FLElement[] traceToRelate get {
		return traces.toFilterByType(FLTraceType.RELATE)
	}
	refers FLElement[] traceToAffect get {
		return traces.toFilterByType(FLTraceType.AFFECT)
	}
	refers FLElement[] traceToSatisfy get {
		return traces.toFilterByType(FLTraceType.SATISFY)
	}
	refers FLElement[] traceToVerify get {
		return traces.toFilterByType(FLTraceType.VERIFY)
	}
	refers FLElement[] traceToRefine get {
		return traces.toFilterByType(FLTraceType.REFINE)
	}
	refers FLElement[] traceToTrack get {
		return traces.toFilterByType(FLTraceType.TRACK)
	}
	
	refers FLElement[] traceFromOwn get {
		return this.fromFilterByType(FLTraceType.OWN)
	}
	refers FLElement[] traceFromUse get {
		return this.fromFilterByType(FLTraceType.USE)
	}
	refers FLElement[] traceFromRealize get {
		return this.fromFilterByType(FLTraceType.REALIZE)
	}
	refers FLElement[] traceFromSpecify get {
		return this.fromFilterByType(FLTraceType.SPECIFY)
	}
	refers FLElement[] traceFromImplement get {
		return this.fromFilterByType(FLTraceType.IMPLEMENT)
	}
	refers FLElement[] traceFromElaborate get {
		return this.fromFilterByType(FLTraceType.ELABORATE)
	}
	refers FLElement[] traceFromDerive get {
		return this.fromFilterByType(FLTraceType.DERIVE)
	}
	refers FLElement[] traceFromValidate get {
		return this.fromFilterByType(FLTraceType.VALIDATE)
	}
	refers FLElement[] traceFromTest get {
		return this.fromFilterByType(FLTraceType.TEST)
	}
	refers FLElement[] traceFromRelate get {
		return this.fromFilterByType(FLTraceType.RELATE)
	}
	refers FLElement[] traceFromAffect get {
		return this.fromFilterByType(FLTraceType.AFFECT)
	}
	refers FLElement[] traceFromSatisfy get {
		return this.fromFilterByType(FLTraceType.SATISFY)
	}
	refers FLElement[] traceFromVerify get {
		return this.fromFilterByType(FLTraceType.VERIFY)
	}
	refers FLElement[] traceFromRefine get {
		return this.fromFilterByType(FLTraceType.REFINE)
	}
	refers FLElement[] traceFromTrack get {
		return this.fromFilterByType(FLTraceType.TRACK)
	}
	/*
	 * Filters the traces to by trace type.
	 * @return filtered list
	 */
	op FLElement[] toFilterByType(FLTrace[] traces, FLTraceType traceType) {
		val targets = new BasicEList
		traces.filter[it.traceType == traceType].forEach [
			targets.add(it.target)
		]
		return targets
	}
	
	/*
	 * Filters the traces from by trace type.
	 * @return filtered list
	 */
	op FLElement[] fromFilterByType(FLElement instance, FLTraceType traceType) {
		val sources = new BasicEList
		if (instance.cdoView != null && !instance.cdoView.isClosed) {
			val xrefs = instance.cdoView.queryXRefs(instance, newArrayList(Literals.FL_TRACE__TARGET))
			for (x : xrefs) {
				val trace = x.sourceObject as FLTrace
				if (trace.traceType == traceType) {
					sources.add(trace.eContainer as FLElement)
				}			
			}
		}
		return sources
	}
}

class FLPackage extends FLElement {
	contains FLElement[] elements
	refers FLPackage[] subPackages get {
		elements.filter(FLPackage).asEList
	}
	refers FLElement[] contents get {
		elements.filter[!(it instanceof FLPackage)].asEList
	}
}

class FLTrace {
	FLTraceType[1] traceType
	refers FLElement[1] target
}

/*
 * Expresses the concrete type of a relationship between entities.
 */
enum FLTraceType {
	/*
	 * ---------------------------------------------
	 * UML2
	 * ---------------------------------------------
	 */
	own = 101
	use = 102
	realize = 103
	specify = 104
	implement = 105
	elaborate = 106
	derive = 107
	/*
	 * ---------------------------------------------
	 * Test Management Domain
	 * ---------------------------------------------
	 */
	/* 
	 * OSLC TM - A test case validates a requirement
	 */
	validate = 201
	/* 
	 * OSLC TM / CM - A test case tests a change request
	 */
	test = 202
	/* 
	 *  OSLC TM / CM - A test case relates to a change request
	 */
	relate = 203
	/* 
	 * OSLC TM - A defect may be said to affect a requirement.
	 */
	affect = 204
	/*
	 * ---------------------------------------------
	 * Requirement Management Domain
	 * ---------------------------------------------
	 */
	/*
	 * SYSML REQ - A requirement satisfy a requirement
	 */
	satisfy = 301
	/*
	 * SYSML REQ - A requirement satisfy a requirement
	 */
	verify = 302
	/*
	 * SYSML REQ - A requirement verifies a requirement
	 */
	refine = 303
	/*
	 * ---------------------------------------------
	 * Change Management Domain
	 * ---------------------------------------------
	 */
	/* 
	 * OSLC - CM - A change request tracks the life cycle of a entity
	 */
	track = 401
}

/*
 * Generic Holder for name value pairs
 */
class FLProperty {
	FLIdentifier[1] name
	String[1] value
}

/* 
 * Technical, machine readable identifier should only contain
 * characters matching <em><b>[a-zA-Z0-9_\-\.]*</em></b>
 */
@ExtendedMetaData(name="FLIdentifier", pattern="[a-zA-Z0-9_\\-\\.]*")
type FLIdentifier wraps String

